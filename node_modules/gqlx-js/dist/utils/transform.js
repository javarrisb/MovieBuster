"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transform = void 0;
const helpers_1 = require("../helpers");
const regenerate_1 = require("./regenerate");
const walk = require('acorn-walk');
const legacy = global.regeneratorRuntime;
function transformAwait(expr, apis) {
    const generate = (0, helpers_1.createGenerationMask)();
    const variables = [];
    const block = {
        body: [
            {
                type: 'ReturnStatement',
                argument: expr,
            },
        ],
        type: 'BlockStatement',
    };
    walk.fullAncestor(block, (node, _, ancestors) => {
        if (node.type === 'ArrowFunctionExpression' && (0, helpers_1.mayBeAsync)(node.body)) {
            node.body = {
                type: 'BlockStatement',
                body: [
                    {
                        type: 'ReturnStatement',
                        argument: node.body,
                    },
                ],
            };
        }
        else if (node.type === 'CallExpression') {
            const { callee } = node;
            if (callee.type === 'Identifier') {
                const name = callee.name;
                if (ancestors.length > 1 && apis.includes(name)) {
                    (0, helpers_1.awaitCall)(node, ancestors, variables);
                }
                else if (typeof generate[name] === 'boolean') {
                    generate[name] = true;
                }
            }
        }
    });
    walk.ancestor(block, {
        CallExpression(node, ancestors) {
            const { callee } = node;
            if (callee.type === 'Identifier') {
                const name = callee.name;
                if (ancestors.length > 1 && apis.includes(name)) {
                    (0, helpers_1.awaitCall)(node, ancestors, variables);
                }
                else if (typeof generate[name] === 'boolean') {
                    generate[name] = true;
                }
            }
        },
    });
    (0, helpers_1.generateHelpers)(generate, block);
    return block;
}
function transpileSource(node, api, args) {
    const apiNames = Object.keys(api);
    const asyncApiNames = apiNames.filter(m => api[m]);
    const block = transformAwait(node, asyncApiNames);
    return (0, helpers_1.transpileNode)(block, apiNames, args, []);
}
function defaultWrapper(block) {
    return `try ${block} catch (err) { throw new Error(JSON.stringify(err, Object.getOwnPropertyNames(err))); }`;
}
function defaultRegenerate(source) {
    if (legacy) {
        return (0, regenerate_1.regenerate)(source);
    }
    return source;
}
function transform(gql, api, options = {}) {
    const keys = Object.keys(gql.resolvers);
    const connectors = {};
    const wrapper = options.wrapStatements || defaultWrapper;
    const regenerate = typeof options.regenerate === 'function' ? options.regenerate : defaultRegenerate;
    for (const key of keys) {
        const resolvers = gql.resolvers[key];
        const types = Object.keys(resolvers);
        for (const type of types) {
            const resolver = resolvers[type];
            const connector = connectors[key] || (connectors[key] = {});
            const args = (0, helpers_1.getArguments)(gql.schema.ast, key, type);
            const block = transpileSource(resolver, api, args);
            const source = wrapper(block);
            const target = regenerate(source);
            connector[type] = target;
        }
    }
    return connectors;
}
exports.transform = transform;
//# sourceMappingURL=transform.js.map