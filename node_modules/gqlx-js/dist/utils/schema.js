"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseDynamicSchema = exports.extractResolvers = exports.createEmptyResolvers = void 0;
const graphql_1 = require("graphql");
const language_1 = require("graphql/language");
const helpers_1 = require("../helpers");
const GqlxError_1 = require("../GqlxError");
function parsePureGql(gql) {
    try {
        return (0, graphql_1.parse)(gql);
    }
    catch (e) {
        const { locations: [{ line, column }], } = e;
        throw new GqlxError_1.GqlxError(`Error in GraphQL schema: ${e.message}`, { column, line, range: [0, 0] });
    }
}
function createEmptyResolvers() {
    return {
        Query: {},
        Mutation: {},
        Subscription: {},
    };
}
exports.createEmptyResolvers = createEmptyResolvers;
function extractResolvers(input, resolvers) {
    const source = new language_1.Source(input);
    const lex = new language_1.Lexer(source);
    const tokens = [];
    const types = Object.keys(resolvers);
    const positions = [];
    let mode = undefined;
    while (lex.token.kind !== '<EOF>') {
        let token = lex.advance();
        mode = (0, helpers_1.getMode)(tokens, types, mode);
        if (mode && token.kind === '{') {
            const pos = {
                start: token.start,
                end: token.end,
            };
            const name = (0, helpers_1.getName)(tokens);
            if (!name) {
                throw new GqlxError_1.GqlxError(`Found invalid schema. Could not find a name for the ${mode}.`, {
                    range: [token.start, token.end],
                    column: token.column,
                    line: token.line,
                });
            }
            const exp = (0, helpers_1.getResolver)(input, token.end);
            resolvers[mode][name] = exp;
            lex.token = new language_1.Token(language_1.TokenKind.COMMENT, exp.start, exp.end, token.line, token.column);
            token = lex.advance();
            if (token.kind !== '}') {
                throw new GqlxError_1.GqlxError(`Found invalid token. Expected '}', but found '${token.kind}'.`, {
                    range: [token.start, token.end],
                    column: token.column,
                    line: token.line,
                });
            }
            pos.end = token.end;
            positions.push(pos);
        }
        else {
            tokens.push(token);
        }
    }
    return positions;
}
exports.extractResolvers = extractResolvers;
function parseDynamicSchema(input) {
    const resolvers = createEmptyResolvers();
    const positions = extractResolvers(input, resolvers);
    const text = (0, helpers_1.convertToPureGql)(input, positions);
    const ast = parsePureGql(text);
    return {
        schema: {
            text,
            ast,
        },
        resolvers,
    };
}
exports.parseDynamicSchema = parseDynamicSchema;
//# sourceMappingURL=schema.js.map