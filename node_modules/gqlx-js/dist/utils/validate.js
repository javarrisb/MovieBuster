"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validate = void 0;
const graphql_1 = require("graphql");
const helpers_1 = require("../helpers");
const GqlxError_1 = require("../GqlxError");
const debugNames = ['console', 'assert'];
const standardNames = ['null', 'undefined', 'Array', 'Object', 'Math'];
const walk = require('acorn-walk');
function check(exp, variables, debug = false) {
    walk.recursive(exp, {
        stack: [],
        parameters: [...helpers_1.inbuiltFunctionNames, ...standardNames, ...(debug ? debugNames : [])],
    }, {
        CallExpression(node, state, cont) {
            cont(node.callee, Object.assign(Object.assign({}, state), { stack: [...state.stack, node] }));
            for (const argument of node.arguments) {
                cont(argument, state);
            }
        },
        Identifier(node, state, cont) {
            const last = state.stack[state.stack.length - 1];
            if (!last || last.type === 'CallExpression') {
                const all = [...variables, ...state.parameters];
                if (!all.includes(node.name)) {
                    throw new GqlxError_1.GqlxError(`The variable "${node.name}" is not available in the current context. Available: ${all.join(', ')}.`, (0, GqlxError_1.getErrorLocation)(node));
                }
            }
        },
        VariableDeclaration(node, state, cont) {
            for (const declaration of node.declarations) {
                cont(declaration, state);
                const names = (0, helpers_1.getNames)([declaration.id]);
                state.parameters.push(...names);
            }
        },
        MemberExpression(node, state, cont) {
            cont(node.object, state);
            cont(node.property, Object.assign(Object.assign({}, state), { stack: [...state.stack, node] }));
        },
        ArrowFunctionExpression(node, state, cont) {
            const names = (0, helpers_1.getNames)(node.params);
            cont(node.body, Object.assign(Object.assign({}, state), { parameters: [...state.parameters, ...names] }));
        },
        FunctionExpression(node) {
            throw new GqlxError_1.GqlxError('Using `function` is not allowed. Use arrow functions ("=>") instead.', (0, GqlxError_1.getErrorLocation)(node));
        },
        FunctionDeclaration(node) {
            throw new GqlxError_1.GqlxError('Declaring a new `function` is not allowed. Only anonymous functions ("=>") can be used.', (0, GqlxError_1.getErrorLocation)(node));
        },
        ThisExpression(node) {
            throw new GqlxError_1.GqlxError('Using `this` is not allowed. The context is only given explicitly.', (0, GqlxError_1.getErrorLocation)(node));
        },
        AwaitExpression(node) {
            throw new GqlxError_1.GqlxError('Using `await` is not allowed. Asynchronous calls are automatically wrapped.', (0, GqlxError_1.getErrorLocation)(node));
        },
        UnaryExpression(node) {
            if (node.operator === 'delete') {
                throw new GqlxError_1.GqlxError('Using `delete` is not allowed. Use the spread operator instead.', (0, GqlxError_1.getErrorLocation)(node));
            }
        },
        DebuggerStatement(node) {
            if (!debug) {
                throw new GqlxError_1.GqlxError('The debugger statement can only be used with enabled debug option.', (0, GqlxError_1.getErrorLocation)(node));
            }
        },
    });
}
function validate(gql, api, options) {
    const keys = Object.keys(gql.resolvers);
    const fns = Object.keys(api);
    const schema = (0, graphql_1.buildSchema)(gql.schema.text);
    for (const key of keys) {
        const resolvers = gql.resolvers[key];
        const types = Object.keys(resolvers);
        for (const type of types) {
            const resolver = resolvers[type];
            const args = (0, helpers_1.getArguments)(gql.schema.ast, key, type);
            const variables = [...fns, ...args];
            check(resolver, variables, options && options.debug);
        }
    }
    (0, graphql_1.assertValidSchema)(schema);
}
exports.validate = validate;
//# sourceMappingURL=validate.js.map