"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.wrapInFunctionBlock = exports.insertAwaitedValue = exports.insertNewValue = exports.createVariableDeclaration = exports.wrapInPromiseAll = exports.isNotIdentifier = exports.callFunction = exports.wrapInLambda = exports.wrapInAwait = exports.mayBeAsync = void 0;
function mayBeAsync(node) {
    return node.type === 'MemberExpression' || node.type === 'CallExpression';
}
exports.mayBeAsync = mayBeAsync;
function wrapInAwait(argument) {
    if (argument.type === 'AwaitExpression') {
        return argument;
    }
    return {
        type: 'AwaitExpression',
        argument,
    };
}
exports.wrapInAwait = wrapInAwait;
function wrapInLambda(argument, statements = [], async = false) {
    return {
        type: 'CallExpression',
        callee: {
            type: 'ArrowFunctionExpression',
            expression: true,
            async,
            params: [],
            body: {
                type: 'BlockStatement',
                body: [
                    ...statements,
                    {
                        type: 'ReturnStatement',
                        argument,
                    },
                ],
            },
        },
        optional: false,
        arguments: [],
    };
}
exports.wrapInLambda = wrapInLambda;
function callFunction(name, argument) {
    return {
        type: 'CallExpression',
        callee: {
            type: 'Identifier',
            name,
        },
        optional: false,
        arguments: [argument],
    };
}
exports.callFunction = callFunction;
function isNotIdentifier(name) {
    return {
        type: 'BinaryExpression',
        operator: '!==',
        left: {
            type: 'MemberExpression',
            computed: true,
            optional: true,
            object: {
                type: 'Identifier',
                name: 'obj',
            },
            property: {
                type: 'Identifier',
                name: 'm',
            },
        },
        right: {
            type: 'Identifier',
            name,
        },
    };
}
exports.isNotIdentifier = isNotIdentifier;
function wrapInPromiseAll(argument) {
    return {
        type: 'CallExpression',
        callee: {
            type: 'MemberExpression',
            computed: false,
            optional: false,
            object: {
                type: 'Identifier',
                name: 'Promise',
            },
            property: {
                type: 'Identifier',
                name: 'all',
            },
        },
        optional: false,
        arguments: [argument],
    };
}
exports.wrapInPromiseAll = wrapInPromiseAll;
function createVariableDeclaration(name, init) {
    return {
        type: 'VariableDeclaration',
        kind: 'const',
        declarations: [
            {
                id: {
                    type: 'Identifier',
                    name,
                },
                init,
                type: 'VariableDeclarator',
            },
        ],
    };
}
exports.createVariableDeclaration = createVariableDeclaration;
function insertNewValue(statements, name, init, offset = 1) {
    statements.splice(statements.length - offset, 0, createVariableDeclaration(name, init));
}
exports.insertNewValue = insertNewValue;
function insertAwaitedValue(statements, name, argument, offset = 1) {
    insertNewValue(statements, name, wrapInAwait(argument), offset);
}
exports.insertAwaitedValue = insertAwaitedValue;
function wrapInFunctionBlock(child, name, argument) {
    return wrapInLambda(child, [createVariableDeclaration(name, wrapInAwait(argument))], true);
}
exports.wrapInFunctionBlock = wrapInFunctionBlock;
//# sourceMappingURL=ast.js.map