"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.awaitCall = void 0;
const ast_1 = require("./ast");
function placeVariableClosestBlock(node, ancestors, variable, start) {
    for (let i = start; i--;) {
        const ancestor = ancestors[i];
        const child = ancestors[i + 1];
        if (ancestor.type === 'BlockStatement') {
            const position = ancestor.body.indexOf(child);
            const offset = ancestor.body.length - position;
            (0, ast_1.insertAwaitedValue)(ancestor.body, variable, node, offset);
            break;
        }
        else if (ancestor.type === 'ConditionalExpression') {
            const sub = child === ancestor.consequent ? 'consequent' : 'alternate';
            const ae = (0, ast_1.wrapInFunctionBlock)(child, variable, node);
            const ce = ae.callee;
            const bs = ce.body;
            ancestor[sub] = ae;
            ancestors.splice(i + 1, 0, ae, ce, bs);
            break;
        }
    }
}
function placeAsyncLambda(ancestors, variables, start = ancestors.length) {
    for (let i = start; i--;) {
        const ancestor = ancestors[i];
        if (ancestor.type === 'ArrowFunctionExpression') {
            ancestor.async = true;
            awaitCall(ancestor, ancestors, variables, i);
            break;
        }
    }
}
function placeInAsyncMap(node, previous) {
    switch (previous.type) {
        case 'ReturnStatement':
            previous.argument = (0, ast_1.wrapInAwait)((0, ast_1.wrapInPromiseAll)(node));
            break;
        case 'MemberExpression':
            previous.object = (0, ast_1.wrapInAwait)((0, ast_1.wrapInPromiseAll)(node));
            break;
    }
}
function isAll(callee) {
    return callee.type === 'MemberExpression' && callee.property.type === 'Identifier' && callee.property.name === 'map';
}
function awaitCall(node, ancestors, variables, start = ancestors.length) {
    for (let i = start; i--;) {
        const ancestor = ancestors[i];
        const child = ancestors[i + 1];
        if (node !== ancestor) {
            if (ancestor.type === 'ReturnStatement') {
                ancestor.argument = (0, ast_1.wrapInAwait)(child);
            }
            else if (ancestor.type === 'Property') {
                ancestor.value = (0, ast_1.wrapInAwait)(child);
            }
            else if (ancestor.type === 'MemberExpression') {
                const variable = `_${variables.length}`;
                variables.push(variable);
                placeVariableClosestBlock(node, ancestors, variable, i);
                ancestor.object = {
                    type: 'Identifier',
                    name: variable,
                };
            }
            else if (ancestor.type === 'CallExpression' && child.type !== 'ArrowFunctionExpression') {
                const argIndex = ancestor.arguments.findIndex(m => m === child);
                ancestor.arguments[argIndex] = (0, ast_1.wrapInAwait)(child);
            }
            else if (ancestor.type === 'CallExpression' && isAll(ancestor.callee)) {
                if (child.type === 'ArrowFunctionExpression') {
                    child.async = true;
                }
                placeInAsyncMap(ancestor, ancestors[i - 1]);
            }
            else if (ancestor.type === 'AssignmentExpression') {
                ancestor.right = (0, ast_1.wrapInAwait)(ancestor.right);
            }
            else if (ancestor.type === 'BinaryExpression') {
                if (ancestor.left === child) {
                    ancestor.left = (0, ast_1.wrapInAwait)(child);
                }
                else {
                    ancestor.right = (0, ast_1.wrapInAwait)(child);
                }
            }
            else if (ancestor.type === 'LogicalExpression') {
                if (ancestor.left === child) {
                    ancestor.left = (0, ast_1.wrapInAwait)(child);
                }
                else {
                    ancestor.right = (0, ast_1.wrapInAwait)(child);
                }
            }
            else if (ancestor.type === 'ConditionalExpression') {
                if (ancestor.consequent === child) {
                    ancestor.consequent = (0, ast_1.wrapInAwait)(child);
                }
                else if (ancestor.alternate === child) {
                    ancestor.alternate = (0, ast_1.wrapInAwait)(child);
                }
            }
            else if (ancestor.type === 'SpreadElement') {
                ancestor.argument = (0, ast_1.wrapInAwait)(ancestor.argument);
            }
            else {
                continue;
            }
            placeAsyncLambda(ancestors, variables, i);
            break;
        }
    }
}
exports.awaitCall = awaitCall;
//# sourceMappingURL=await.js.map