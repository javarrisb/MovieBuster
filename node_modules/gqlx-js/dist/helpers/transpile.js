"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transpileNode = exports.transpilePattern = exports.transpileMember = exports.getIdentifier = void 0;
function getIdentifier(name, apis, args, locals) {
    if (locals.indexOf(name) === -1) {
        if (args.indexOf(name) >= 0) {
            return `$data.${name}`;
        }
        else if (apis.indexOf(name) >= 0) {
            return `$api.${name}`;
        }
    }
    return name;
}
exports.getIdentifier = getIdentifier;
function transpileMember(obj, apis, args, locals) {
    const rhs = obj.property.type === 'Identifier'
        ? obj.computed
            ? getIdentifier(obj.property.name, apis, args, locals)
            : obj.property.name
        : transpileNode(obj.property, apis, args, locals);
    const prop = obj.computed ? `[${rhs}]` : `.${rhs}`;
    return `${transpileNode(obj.object, apis, args, locals)}${prop}`;
}
exports.transpileMember = transpileMember;
function transpilePattern(pattern, apis, args, locals) {
    switch (pattern === null || pattern === void 0 ? void 0 : pattern.type) {
        case 'RestElement':
            return '...';
        case 'ArrayPattern':
            return `[${pattern.elements.map(p => transpilePattern(p, apis, args, locals)).join(', ')}]`;
        case 'Identifier':
            return pattern.name;
        case 'AssignmentPattern': {
            const rhs = transpileNode(pattern.right, apis, args, locals);
            return `${transpilePattern(pattern.left, apis, args, locals)} = ${rhs}`;
        }
        case 'ObjectPattern':
            return `{ ${pattern.properties
                .map(p => {
                if (p.type === 'Property') {
                    return transpilePattern(p.value, apis, args, locals);
                }
                else {
                    return '...';
                }
            })
                .join(', ')} }`;
        case 'MemberExpression': {
            return transpileMember(pattern, apis, args, locals);
        }
        default:
            return '';
    }
}
exports.transpilePattern = transpilePattern;
function transpileNode(node, apis, args, locals) {
    switch (node.type) {
        case 'EmptyStatement': {
            return ';';
        }
        case 'PrivateIdentifier': {
            return `#${node.name}`;
        }
        case 'TryStatement': {
            return '';
        }
        case 'ExpressionStatement': {
            const expr = transpileNode(node.expression, apis, args, locals);
            return `${expr};`;
        }
        case 'VariableDeclaration': {
            const decls = node.declarations
                .map(m => {
                const variable = transpilePattern(m.id, apis, args, locals);
                if (m.init) {
                    const init = transpileNode(m.init, apis, args, locals);
                    locals.push(variable);
                    return `${variable} = ${init}`;
                }
                else {
                    locals.push(variable);
                    return variable;
                }
            })
                .join(', ');
            return `${node.kind} ${decls};`;
        }
        case 'CallExpression': {
            const fn = transpileNode(node.callee, apis, args, locals);
            const params = node.arguments.map(a => transpileNode(a, apis, args, locals)).join(', ');
            return `${fn}(${params})`;
        }
        case 'MemberExpression': {
            return transpileMember(node, apis, args, locals);
        }
        case 'ObjectExpression': {
            const properties = node.properties
                .map(p => {
                if (p.type === 'SpreadElement') {
                    const arg = transpileNode(p.argument, apis, args, locals);
                    return `...(${arg})`;
                }
                else {
                    const key = transpileNode(p.key, p.computed ? apis : [], p.computed ? args : [], locals);
                    if (!p.shorthand || [...args, ...apis].indexOf(key) >= 0) {
                        const value = transpileNode(p.value, apis, args, locals);
                        return p.computed ? `[${key}]: ${value}` : `${key}: ${value}`;
                    }
                    return key;
                }
            })
                .join(', ');
            return `({ ${properties} })`;
        }
        case 'ArrayExpression': {
            const elements = node.elements.map(m => transpileNode(m, apis, args, locals)).join(', ');
            return `[${elements}]`;
        }
        case 'TemplateLiteral': {
            const exprs = node.expressions.map(m => transpileNode(m, apis, args, locals));
            const parts = node.quasis.map(m => m.value.raw);
            const snippets = ['`', parts[0], '`'];
            for (let i = 0; i < exprs.length; i++) {
                snippets.splice(2 + 4 * i, 0, '${', exprs[i], '}', parts[i + 1]);
            }
            return snippets.join('');
        }
        case 'AwaitExpression': {
            const expr = transpileNode(node.argument, apis, args, locals);
            return `await ${expr}`;
        }
        case 'ConditionalExpression': {
            const condition = transpileNode(node.test, apis, args, locals);
            const primary = transpileNode(node.consequent, apis, args, locals);
            const secondary = transpileNode(node.alternate, apis, args, locals);
            return `((${condition}) ? (${primary}) : (${secondary}))`;
        }
        case 'LogicalExpression': {
            const left = transpileNode(node.left, apis, args, locals);
            const right = transpileNode(node.right, apis, args, locals);
            return `(${left} ${node.operator} ${right})`;
        }
        case 'AssignmentExpression': {
            const variable = node.left.type === 'Identifier'
                ? transpileNode(node.left, apis, args, locals)
                : transpilePattern(node.left, apis, args, locals);
            const value = transpileNode(node.right, apis, args, locals);
            return `(${variable} = ${value})`;
        }
        case 'BinaryExpression': {
            const left = transpileNode(node.left, apis, args, locals);
            const right = transpileNode(node.right, apis, args, locals);
            return `(${left} ${node.operator} ${right})`;
        }
        case 'UpdateExpression':
        case 'UnaryExpression': {
            const value = transpileNode(node.argument, apis, args, locals);
            if (node.prefix) {
                return `(${node.operator}${value})`;
            }
            return `(${value}${node.operator})`;
        }
        case 'ReturnStatement': {
            const expr = node.argument ? transpileNode(node.argument, apis, args, locals) : '';
            return `return ${expr};`;
        }
        case 'Literal': {
            return node.raw || '';
        }
        case 'BlockStatement': {
            const localLocals = [...locals];
            const statements = node.body.map(stmt => transpileNode(stmt, apis, args, localLocals)).join(' ');
            return `{ ${statements} }`;
        }
        case 'IfStatement': {
            const condition = transpileNode(node.test, apis, args, locals);
            const primary = transpileNode(node.consequent, apis, args, locals);
            const rest = node.alternate ? ` else ${transpileNode(node.alternate, apis, args, locals)}` : '';
            return `if (${condition}) ${primary}${rest}`;
        }
        case 'WhileStatement': {
            const condition = transpileNode(node.test, apis, args, locals);
            const body = transpileNode(node.body, apis, args, locals);
            return `while (${condition}) ${body}`;
        }
        case 'DoWhileStatement': {
            const condition = transpileNode(node.test, apis, args, locals);
            const body = transpileNode(node.body, apis, args, locals);
            return `do ${body} while (${condition});`;
        }
        case 'ForStatement': {
            const init = node.init ? transpileNode(node.init, apis, args, locals).replace(/;$/, '') : '';
            const test = node.test ? transpileNode(node.test, apis, args, locals) : '';
            const update = node.update ? transpileNode(node.update, apis, args, locals) : '';
            const body = transpileNode(node.body, apis, args, locals);
            return `for (${init}; ${test}; ${update}) ${body}`;
        }
        case 'ArrowFunctionExpression': {
            const params = node.params.map(p => transpilePattern(p, apis, args, locals));
            const body = transpileNode(node.body, apis, args, [...locals, ...params]);
            const async = node.async ? 'async ' : '';
            return `(${async}(${params.join(', ')}) => ${body})`;
        }
        case 'Identifier': {
            return getIdentifier(node.name, apis, args, locals);
        }
        case 'SpreadElement': {
            const rest = transpileNode(node.argument, apis, args, locals);
            return `...${rest}`;
        }
        case 'DebuggerStatement': {
            return 'debugger;';
        }
        case 'ParenthesizedExpression': {
            return transpileNode(node.expression, apis, args, locals);
        }
        default:
            return '';
    }
}
exports.transpileNode = transpileNode;
//# sourceMappingURL=transpile.js.map