"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.configureGqlx = void 0;
const apollo_server_express_1 = require("apollo-server-express");
const context_1 = require("./context");
const utils_1 = require("./utils");
const subscription_1 = require("./subscription");
const schema_1 = require("./schema");
const constants_1 = require("./constants");
const gateway_1 = require("./gateway");
function configureGqlx(options) {
    const { maxFiles = 1, maxFileSize = 16 * 1024 * 1024, paths = {}, host, keepAlive, introspection = true, logError = utils_1.defaultErrorLogger, formatter = utils_1.tryParseJson, services, createApi = constants_1.defaultApiCreator, tracing = false, cacheControl = true, } = options;
    const schema = (0, schema_1.createSchema)(services);
    const gqlxServer = {
        applyMiddleware(app) {
            const gateway = (0, gateway_1.createGateway)(schema);
            const path = paths.endpoint || constants_1.defaultEndpointPath;
            const server = new apollo_server_express_1.ApolloServer({
                introspection,
                tracing,
                cacheControl,
                uploads: {
                    maxFiles,
                    maxFileSize,
                },
                subscriptions: false,
                gateway,
                context({ req }) {
                    return (0, context_1.createContext)(req, services, createApi);
                },
                formatError(err) {
                    const path = (err && err.path && err.path[0]) || 'error';
                    const details = formatter(err && err.message);
                    logError(String(path), details);
                    return {
                        [path]: details,
                    };
                },
                playground: paths.graphiql !== false
                    ? {
                        endpoint: path,
                        subscriptionEndpoint: (0, utils_1.getSubscriptionEndpoint)(host, paths.subscriptions),
                    }
                    : false,
            });
            server.applyMiddleware({ app, path });
            if (typeof paths.graphiql === 'string' && paths.graphiql !== path) {
                app.get(paths.graphiql, (_, res) => res.redirect(path));
            }
            return server;
        },
        subscribe(server) {
            const unsubscribe = (0, subscription_1.createSubscription)(server, {
                keepAlive,
                createApi,
                paths,
                schema,
                services,
            });
            server.on('close', unsubscribe);
            return unsubscribe;
        },
        update(newService) {
            try {
                if (newService) {
                    const serviceName = newService.name;
                    const newServices = services.map(oldService => (oldService.name === serviceName ? newService : oldService));
                    services.splice(0, services.length, ...newServices);
                }
                schema.update(services);
            }
            catch (err) {
                logError(`update/${newService === null || newService === void 0 ? void 0 : newService.name}`, err);
            }
        },
        insert(service) {
            try {
                const existingService = gqlxServer.get(service.name);
                if (existingService !== undefined) {
                    gqlxServer.update(service);
                }
                else {
                    const newServices = [...services, service];
                    services.splice(0, services.length, ...newServices);
                    gqlxServer.update();
                }
            }
            catch (err) {
                logError(`insert/${service === null || service === void 0 ? void 0 : service.name}`, err);
            }
        },
        remove(serviceName) {
            try {
                const newServices = services.filter(svc => svc.name !== serviceName);
                services.splice(0, services.length, ...newServices);
                gqlxServer.update();
            }
            catch (err) {
                logError(`remove/${serviceName}`, err);
            }
        },
        get(serviceName) {
            const [service] = services.filter(svc => svc.name === serviceName);
            return service;
        },
    };
    return gqlxServer;
}
exports.configureGqlx = configureGqlx;
//# sourceMappingURL=configure.js.map